# 笔记

## 13深度+法线纹理

### 两种纹理的获取

相机脚本中添加代码：

```
camera.depthTextureMode |= DepthTextureMode.Depth;
camera.depthTextureMode |= DepthTextureMode.DepthNormals;
```

此后在shader的片元着色器中可调用

```
float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);
```

### 运动模糊*

上一章的运动模糊是混合多张图像，此处使用更泛用的速度映射图。

这里的_PreviousViewProjectionMatri是视角 * 投影矩阵（上一帧的），用来算上一帧的NDC，即**当前矩阵+当前世界空间坐标 = 当前NDC**，**上一帧矩阵+当前世界空间坐标 = 上一帧NDC**

则传进shader的参数就是**当前矩阵求逆+上一帧矩阵**

> 利用**深度纹理**在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角 * 投影矩阵的逆矩阵对NDC下的顶点坐标进行变换得到的。当得到**世界空间中的顶点坐标**后，我们使用前一帧的视角 * 投影矩阵对其进行变换，得到该位置在**前一帧中的NDC坐标**。然后我们在计算前一帧与当前帧的位置差，生成该像素的速度。

```
void OnRenderImage (RenderTexture src, RenderTexture dest) {
		if (material != null) {
			material.SetFloat("_BlurSize", blurSize);

			material.SetMatrix("_PreviousViewProjectionMatrix", previousViewProjectionMatrix);
			Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;
			Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;
			material.SetMatrix("_CurrentViewProjectionInverseMatrix", currentViewProjectionInverseMatrix);
			previousViewProjectionMatrix = currentViewProjectionMatrix;

			Graphics.Blit (src, dest, material);
		} else {
			Graphics.Blit(src, dest);
		}
	}
```

以下是shader：

视角 * 投影矩阵  以下简称  矩阵

采样得到深度纹理d

```
fixed4 frag(v2f i) : SV_Target {
			float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);
```

H是NDC，h = 2d-1；h[-1,1]，d[0,1]

```
float4 H = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, d * 2 - 1, 1);
```

用当前矩阵与H相乘，再除以他的w分量（这是在将坐标转化为齐次坐标），转换到世界坐标

```
float4 D = mul(_CurrentViewProjectionInverseMatrix, H);
float4 worldPos = D / D.w;
```

再用上一帧矩阵和世界坐标相乘，转换得上一帧的NDC

```
float4 currentPos = H;
float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);
```

由两个NDC得到速度，叠加到采样结果上

```
float2 velocity = (currentPos.xy - previousPos.xy)/2.0f;
float2 uv = i.uv;
float4 c = tex2D(_MainTex, uv);
uv += velocity * _BlurSize;
```

接下来做两次次采样（？

似乎这么做的目的是对左右领域采样并叠加，取平均得到最终结果

```
for (int it = 1; it < 3; it++, uv += velocity * _BlurSize) {
				float4 currentColor = tex2D(_MainTex, uv);
				c += currentColor;
			}
c /= 3;
return fixed4(c.rgb, 1.0);
```

### 全局雾效

#### 世界坐标的另一种获取方法

基本思路：相机的世界坐标（_WorldSpaceCameraPos）+　点相对相机的偏移　＝　点的世界坐标

```
float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;
```

点相对相机的偏移　＝　由深度纹理得到的深度值　*　由顶点着色器输出并插值后得到的射线

射线需要计算**近裁剪平面**的四个顶点 **相对摄像机原点的射线**，包括距离和方向

p278照着图推一遍就能看懂，near是摄像机原点到平面的距离

TL即topleft到摄像机原点距离

```
Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;
Vector3 topRight = cameraTransform.forward * near + toRight + toTop;
Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;
Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;
```

由于depth（深度纹理）不等于TL，而是TL在摄像机原点的z轴的投影，因此有：disTL = abs(TL)/near*depth

toTop 和 toRight是什么？

起点位于近裁剪平面，指向摄像机上方和右方的向量，有了这两个数值就能求得上面四个向量

```
float halfHeight = near * Mathf.Tan(fov * 0.5f * Mathf.Deg2Rad);
Vector3 toRight = cameraTransform.right * halfHeight * aspect;
Vector3 toTop = cameraTransform.up * halfHeight;
```



#### 雾效计算

雾效生成原理是在**输出颜色时与该点应该有的雾效颜色混合**

```
afterfog = f * fogcolor ＋　(1-f) * origcolor
```

f是一个系数，我们可以在设定了雾效的生成高度区间Hend ，Hstart后求得某一高度y处的雾效系数f
$$
f = (Hend - y )/ (Hend - Hstart)
$$
以下是正式代码：

照例获取深度纹理

```
	void OnEnable() {
		camera.depthTextureMode |= DepthTextureMode.Depth;
	}
```

脚本中新建一个矩阵，求得vector3向量后插入矩阵（共四个）

```
Matrix4x4 frustumCorners = Matrix4x4.identity;
frustumCorners.SetRow(0, bottomLeft);
```

接下来传参矩阵和一些系数

```
material.SetMatrix("_FrustumCornersRay", frustumCorners);
...
Graphics.Blit (src, dest, material);
```

shader中按照“左下(0，0)，右上(1，1)”的规律判断上面传参的矩阵，存的时候也是这个顺序，即判断当前顶点在四个角的哪一个，**因为是屏幕后处理只有四个顶点需要处理，所以基本没有消耗**

```
			int index = 0;
			if (v.texcoord.x < 0.5 && v.texcoord.y < 0.5) {
				index = 0;
			} else if (v.texcoord.x > 0.5 && v.texcoord.y < 0.5) {
				index = 1;
			} else if (v.texcoord.x > 0.5 && v.texcoord.y > 0.5) {
				index = 2;
			} else {
				index = 3;
			}
						#if UNITY_UV_STARTS_AT_TOP
			if (_MainTex_TexelSize.y < 0)
				index = 3 - index;
			#endif
			
			o.interpolatedRay = _FrustumCornersRay[index];
```

最后在片元着色器中计算雾效

```
o.uv_depth = v.texcoord;
			
			#if UNITY_UV_STARTS_AT_TOP
			if (_MainTex_TexelSize.y < 0)
				o.uv_depth.y = 1 - o.uv_depth.y;
			#endif
```

先采样深度纹理（不是用tex2D）再LinearEyeDepth得到视角空间下的线性深度值

```
float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));
```

interpolatedRay是相机->像素的向量
$$
世界下相机坐标+相机下像素深度*相机->像素 = 世界下像素坐标
$$


```
float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;
```

接下来求雾效系数，当前高度worldPos.y可得

```
float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); 
fogDensity = saturate(fogDensity * _FogDensity);
```

接着用tex2D获取物体纹理颜色，与雾效混合后返回即可

```
fixed4 finalColor = tex2D(_MainTex, i.uv);
			finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);
```

### 边缘检测

sobel算子的边缘检测会受到场景颜色的影响，但基于深度纹理的边缘检测就能更好地处理这种情况。这里使用了roberts算子判断是否是边缘。

脚本开放以下几个参数， sampleDistance控制在对深度+法线纹理采样时的采样距离，即这个数值越大，描边越明显。

sensitivityDepth和sensitivityNormals是邻域的深度/法线值相差多少时被判定为边缘。

至于edgesOnly，是最终输出颜色时边缘的占比，等于1图中只剩边缘。这种情况下图中就只剩背景颜色和边缘。

```
public float edgesOnly = 0.0f;
public Color edgeColor = Color.black;
public Color backgroundColor = Color.white;
public float sampleDistance = 1.0f;
public float sensitivityDepth = 1.0f;
public float sensitivityNormals = 1.0f;
```

函数前加上这句，因为我们不需要透明物体也 加上边缘（受此函数影响）

```
[ImageEffectOpaque]
	void OnRenderImage (RenderTexture src, RenderTexture dest)
```

以下是shader

数组存的是采样**物体**纹理时roberts算子各邻域的采样数值，这里就可以加入采样距离的控制了。

```
v2f vert(appdata_img v) {...
			o.uv[0] = v.texcoord;
			o.uv[1] = uv + _MainTex_TexelSize.xy * half2(1,1) * _SampleDistance;
			o.uv[2] = uv + _MainTex_TexelSize.xy * half2(-1,-1) * _SampleDistance;
			o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1,1) * _SampleDistance;
			o.uv[4] = uv + _MainTex_TexelSize.xy * half2(1,-1) * _SampleDistance;
					 
			return o;
		}
```

片元里先在四个邻域位置上采样深度+法线纹理，按算子的思路判边缘

11右上和-1-1左下成对判断，-11左上和1-1右下成对判断。一对采样结果分别得到深度和法线的差值，都大于各自阈值则判定有边缘。

```

		fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target {
			half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[1]);
			half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[2]);
			half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[3]);
			half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[4]);
			half edge = 1.0;
			edge *= CheckSame(sample1, sample2);
			edge *= CheckSame(sample3, sample4);
		}
		
```

CheckSame函数只返回01,0则有边界->withEdgeColor插值=_EdgeColor->显示边界

```
fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[0]), edge);
			fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);
```

注意tex2D的返回值里xy是法线，zw是深度

```
half CheckSame(half4 center, half4 sample) {
			half2 centerNormal = center.xy;
			float centerDepth = DecodeFloatRG(center.zw);
			half2 sampleNormal = sample.xy;
			float sampleDepth = DecodeFloatRG(sample.zw);
			
			half2 diffNormal = abs(centerNormal - sampleNormal) * _Sensitivity.x;
			int isSameNormal = (diffNormal.x + diffNormal.y) < 0.1;
			
			float diffDepth = abs(centerDepth - sampleDepth) * _Sensitivity.y;
			int isSameDepth = diffDepth < 0.1 * centerDepth;
			
			return isSameNormal * isSameDepth ? 1.0 : 0.0;
		}
```

## 14.1卡通渲染

基础在于**添加边缘+高光**，这两点的实现都和此前内容有区别。

#### 边缘

基于轮廓边检测的渲染：怎么检测轮廓边？
$$
(n0 * v) 不等于 (n1 * v) 
$$
n0，n1是一条边相邻两个面的法向，v是视点到这条边任一点的向量。通俗来说就是检测两个相邻三角面片是否一个正向一个反向。缺点是这个方法在帧之间检测，会造成帧之间边缘没有过渡，产生突变。

过程式：一个pass渲染背面，在视角空间下让模型顶点扩张一段距离，实现背部轮廓线可见。下一个pass再渲染正面

#### 高光

Blinn-Phong模型高光

```
float spec = pow(max(0,dot(normal,halfDir)),_Gloss)
```

dot(normal,halfDir)是个关键的系数

卡通模型高光

简单版本，step(a,b) = a<b ? 0 : 1

```
float spec = dot (worldNormal,worldHalfDir)
spec = step(threshold,spec)
```

这个写法高光边缘会突变，所以加个插值。

w是个很小的数值，smoothstep(-w,w,a) 当a在[-w,w]外返回0，否则在区间内插值，这样高光边缘区域就有平滑。

```
float spec = dot (worldNormal,worldHalfDir)
spec = lerp(0,1,smoothstep(-w,w,spec-threshold))
```

#### 具体实现



颜色，纹理，漫反射的渐变纹理，轮廓线宽度，轮廓线颜色，高光颜色，高光阈值

```
Properties {
		_Color ("Color Tint", Color) = (1, 1, 1, 1)
		_MainTex ("Main Tex", 2D) = "white" {}
		_Ramp ("Ramp Texture", 2D) = "white" {}
		_Outline ("Outline", Range(0, 1)) = 0.1
		_OutlineColor ("Outline Color", Color) = (0, 0, 0, 1)
		_Specular ("Specular", Color) = (1, 1, 1, 1)
		_SpecularScale ("Specular Scale", Range(0, 0.1)) = 0.01
	}
```

##### 背面pass

此pass只渲染轮廓线

```
Pass {
			NAME "OUTLINE"
			Cull Front//删除正面
```

顶点着色器中扩张法线，处理法线要在视角空间下（？，归一化后**沿法线方向**扩张一定距离，再转换回裁剪空间

```
v2f vert (a2v v) {
				v2f o;
				float4 pos = mul(UNITY_MATRIX_MV, v.vertex); 
				float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  
				normal.z = -0.5;
				pos = pos + float4(normalize(normal), 0) * _Outline;
				o.pos = mul(UNITY_MATRIX_P, pos);
				
				return o;
			}
```

因为是背面，背面只需要体现轮廓线颜色就行，所以全上轮廓线颜色

```
float4 frag(v2f i) : SV_Target { 
				return float4(_OutlineColor.rgb, 1); 
			}
```

##### 正面pass

正面pass关键在于光照的计算，阴影按标准代码来

```
v2f vert (a2v v) {
				v2f o;
				o.pos = UnityObjectToClipPos( v.vertex);
				o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);
				o.worldNormal  = UnityObjectToWorldNormal(v.normal);
				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
				TRANSFER_SHADOW(o);
				
				return o;
			}
float4 frag(v2f i) : SV_Target { 
				fixed3 worldNormal = normalize(i.worldNormal);
				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
				fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
				fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);
				
				fixed4 c = tex2D (_MainTex, i.uv);
				fixed3 albedo = c.rgb * _Color.rgb;
```

漫反射还要考虑**漫反射纹理**_Ramp的颜色，diff半兰伯特系数，在片元里计算，因此是逐相似光照

此处见7.3渐变纹理	

```
fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
				
				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
				fixed diff =  dot(worldNormal, worldLightDir);
				diff = (diff * 0.5 + 0.5) * atten;
				fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;
```

w可以自己写一个极小值，这里用的边缘导数近似w

step(0.0001, _SpecularScale)确保 _SpecularScale只在等于0时关闭高光

```
fixed spec = dot(worldNormal, worldHalfDir);
				fixed w = fwidth(spec) * 2.0;
				fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale);
				
				return fixed4(ambient + diffuse + specular, 1.0);
```

##14.2素描渲染

和卡通渲染思路相似，背面还是只做轮廓线渲染，正面的纹理是6张由浅到深的笔触纹理混合而成的，用以控制笔触效果的深浅。

这里是逐顶点光照，diff在vert里计算， _TileFactor是**纹理平铺系数**，越大笔触越多

```
v2f vert(a2v v) {
				v2f o;
				
				o.pos = UnityOb	jectToClipPos(v.vertex);
				o.uv = v.texcoord.xy * _TileFactor;
				
				fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));
				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);
				fixed diff = max(0, dot(worldLightDir, worldNormal));
				float hatchFactor = diff * 7.0;
```

o.hatchWeights0和1的xyz正好6个数值对应6个权重

```
				o.hatchWeights0 = fixed3(0, 0, 0);
				o.hatchWeights1 = fixed3(0, 0, 0);
				if (hatchFactor > 6.0) {
				} else if (hatchFactor > 5.0) {
					o.hatchWeights0.x = hatchFactor - 5.0;
				} else if (hatchFactor > 4.0) {
					o.hatchWeights0.x = hatchFactor - 4.0;
					o.hatchWeights0.y = 1.0 - o.hatchWeights0.x;
				} else if (hatchFactor > 3.0) {
					o.hatchWeights0.y = hatchFactor - 3.0;
					o.hatchWeights0.z = 1.0 - o.hatchWeights0.y;
				} else if (hatchFactor > 2.0) {
					o.hatchWeights0.z = hatchFactor - 2.0;
					o.hatchWeights1.x = 1.0 - o.hatchWeights0.z;
				} else if (hatchFactor > 1.0) {
					o.hatchWeights1.x = hatchFactor - 1.0;
					o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;
				} else {
					o.hatchWeights1.y = hatchFactor;
					o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;
				}
				
				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
				
				TRANSFER_SHADOW(o);
				
				return o; 
			}
```

片元用得到的权重采样，另外计算纯白的比重，由1-全部权重和得到

```

			fixed4 frag(v2f i) : SV_Target {			
				fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;
				fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;
				...
				fixed4 whiteColor = fixed4(1, 1, 1, 1) * (1 - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - 
							i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);
				
				fixed4 hatchColor = hatchTex0 + hatchTex1 ... whiteColor;
				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);				
				return fixed4(hatchColor.rgb * _Color.rgb * atten, 1.0);
			}
```

