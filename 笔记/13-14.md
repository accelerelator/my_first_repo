# 笔记

## 13深度+法线纹理

### 两种纹理的获取

相机脚本中添加代码：

```
camera.depthTextureMode |= DepthTextureMode.Depth;
camera.depthTextureMode |= DepthTextureMode.DepthNormals;
```

此后在shader的片元着色器中可调用

```
float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);
```

### 运动模糊*

上一章的运动模糊是混合多张图像，此处使用更泛用的速度映射图。

这里的_PreviousViewProjectionMatri是视角 * 投影矩阵（上一帧的），用来算上一帧的NDC，即**当前矩阵+当前世界空间坐标 = 当前NDC**，**上一帧矩阵+当前世界空间坐标 = 上一帧NDC**

则传进shader的参数就是**当前矩阵求逆+上一帧矩阵**

> 利用**深度纹理**在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角 * 投影矩阵的逆矩阵对NDC下的顶点坐标进行变换得到的。当得到**世界空间中的顶点坐标**后，我们使用前一帧的视角 * 投影矩阵对其进行变换，得到该位置在**前一帧中的NDC坐标**。然后我们在计算前一帧与当前帧的位置差，生成该像素的速度。

```
void OnRenderImage (RenderTexture src, RenderTexture dest) {
		if (material != null) {
			material.SetFloat("_BlurSize", blurSize);

			material.SetMatrix("_PreviousViewProjectionMatrix", previousViewProjectionMatrix);
			Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;
			Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;
			material.SetMatrix("_CurrentViewProjectionInverseMatrix", currentViewProjectionInverseMatrix);
			previousViewProjectionMatrix = currentViewProjectionMatrix;

			Graphics.Blit (src, dest, material);
		} else {
			Graphics.Blit(src, dest);
		}
	}
```

以下是shader：

视角 * 投影矩阵  以下简称  矩阵

采样得到深度纹理d

```
fixed4 frag(v2f i) : SV_Target {
			float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);
```

H是NDC，h = 2d-1；h[-1,1]，d[0,1]

```
float4 H = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, d * 2 - 1, 1);
```

用当前矩阵与H相乘，再除以他的w分量，转换到世界坐标

```
float4 D = mul(_CurrentViewProjectionInverseMatrix, H);
float4 worldPos = D / D.w;
```

再用上一帧矩阵和世界坐标相乘，转换得上一帧的NDC

```
float4 currentPos = H;
float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);
```

由两个NDC得到速度，叠加到采样结果上

```
float2 velocity = (currentPos.xy - previousPos.xy)/2.0f;
float2 uv = i.uv;
float4 c = tex2D(_MainTex, uv);
uv += velocity * _BlurSize;
```

接下来做两次次采样（？

似乎这么做的目的是对左右领域采样并叠加，取平均得到最终结果

```
for (int it = 1; it < 3; it++, uv += velocity * _BlurSize) {
				float4 currentColor = tex2D(_MainTex, uv);
				c += currentColor;
			}
c /= 3;
return fixed4(c.rgb, 1.0);
```

### 全局雾效

#### 世界坐标的另一种获取方法

基本思路：相机的世界坐标（_WorldSpaceCameraPos）+　点相对相机的偏移　＝　点的世界坐标

```
float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;
```

点相对相机的偏移　＝　由深度纹理得到的深度值　*　由顶点着色器输出并插值后得到的射线

射线需要计算**近裁剪平面**的四个顶点 **相对摄像机原点的射线**，包括距离和方向

p278照着图推一遍就能看懂，near是摄像机原点到平面的距离

TL即topleft到摄像机原点距离

```
Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;
Vector3 topRight = cameraTransform.forward * near + toRight + toTop;
Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;
Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;
```

由于depth（深度纹理）不等于TL，而是TL在摄像机原点的z轴的投影，因此有：disTL = abs(TL)/near*depth

toTop 和 toRight是什么？

起点位于近裁剪平面，指向摄像机上方和右方的向量，有了这两个数值就能求得上面四个向量

```
float halfHeight = near * Mathf.Tan(fov * 0.5f * Mathf.Deg2Rad);
Vector3 toRight = cameraTransform.right * halfHeight * aspect;
Vector3 toTop = cameraTransform.up * halfHeight;
```



#### 雾效计算

雾效生成原理是在**输出颜色时与该点应该有的雾效颜色混合**

```
afterfog = f * fogcolor ＋　(1-f) * origcolor
```

f是一个系数，我们可以在设定了雾效的生成高度区间Hend ，Hstart后求得某一高度y处的雾效系数f
$$
f = (Hend - y )/ (Hend - Hstart)
$$
以下是正式代码：

照例获取深度纹理

```
	void OnEnable() {
		camera.depthTextureMode |= DepthTextureMode.Depth;
	}
```

脚本中新建一个矩阵，求得vector3向量后插入矩阵（共四个）

```
Matrix4x4 frustumCorners = Matrix4x4.identity;
frustumCorners.SetRow(0, bottomLeft);
```

接下来传参矩阵和一些系数

```
material.SetMatrix("_FrustumCornersRay", frustumCorners);
...
Graphics.Blit (src, dest, material);
```

shader中按照“左下(0，0)，右上(1，1)”的规律获取上面传参的矩阵，存的时候也是这个顺序

```
			int index = 0;
			if (v.texcoord.x < 0.5 && v.texcoord.y < 0.5) {
				index = 0;
			} else if (v.texcoord.x > 0.5 && v.texcoord.y < 0.5) {
				index = 1;
			} else if (v.texcoord.x > 0.5 && v.texcoord.y > 0.5) {
				index = 2;
			} else {
				index = 3;
			}
						#if UNITY_UV_STARTS_AT_TOP
			if (_MainTex_TexelSize.y < 0)
				index = 3 - index;
			#endif
			
			o.interpolatedRay = _FrustumCornersRay[index];
```

最后在片元着色器中计算雾效，先采样深度纹理（不是用tex2D）

```
o.uv_depth = v.texcoord;
			
			#if UNITY_UV_STARTS_AT_TOP
			if (_MainTex_TexelSize.y < 0)
				o.uv_depth.y = 1 - o.uv_depth.y;
			#endif
```

```
float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));
```

世界坐标的获取

```
float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;
```

接下来求雾效系数，当前高度worldPos.y可得

```
float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); 
			fogDensity = saturate(fogDensity * _FogDensity);
```

接着用tex2D获取物体纹理颜色，与雾效混合后返回即可

```
fixed4 finalColor = tex2D(_MainTex, i.uv);
			finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);
```

