# 笔记

## 杂项

tex2D结果[0,1]，unpakcnormal(tex2D)是把结果映射到[0,255]

计算时尽可能把结果放在[0,1]内（貌似？

## 15噪声

### 15.1消融

原理：给定一张噪声纹理，如果采样结果小于阈值就clip掉，**消除部分和保留部分的边缘**是两部分颜色混合，pow函数处理后与原纹理混合得到的结果。

#### 基本pass



当早上纹理小于阈值，clip参数小于0，则将此像素剔除

```

			fixed4 frag(v2f i) : SV_Target {
				fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;
				
				clip(burn.r - _BurnAmount);
```

略过基本光照计算，_LineWidth指颜色过渡区域的宽度

t 在[0,1]内，作为系数，表示当前像素处在过渡区域的哪个位置

```
fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);
				fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);
				burnColor = pow(burnColor, 5);
				
				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);
```

系数作为步长参与插值，step作用是让 _BurnAmount = 0时关闭效果

```
fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));
				
				return fixed4(finalColor, 1);
```

#### 阴影pass

因为消融后模型内部会外露，重点就是clip指令，确保被剔除了的部分不会投射阴影。

阴影pass的两个指令

```
Tags { "LightMode" = "ShadowCaster" }
#pragma multi_compile_shadowcaster
```

```
v2f vert(appdata_base v) {
				o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);}
```

```
fixed4 frag(v2f i) : SV_Target {
				fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;
				clip(burn.r - _BurnAmount);
			}
```

###15.2水面

噪声贴图影响水面法线，进而影响折射反射效果

此处shader与10.2.2相似。cubemap作为环境纹理模拟反射。GrabPass获取屏幕纹理，并在切线空间下对像素屏幕坐标进行偏移（**向着法线方向**），再用偏移后的坐标对渲染纹理做屏幕采样。

区别在于此处法线方向是噪声贴图的方向。以及混合反射折射时不再是开放固定参数，而是计算菲涅尔系数。v视角方向，n法线方向，夹角越小，系数越小，对应影响反射约弱，折射越强。
$$
fresnel = pow (1-max(0,v*n),4)
$$
shader中顶点照抄10.2.2，片元先获取世界坐标

```
fixed4 frag(v2f i) : SV_Target {
				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);
```

计算当前时间影响的偏移量（开放速度参数）

```
fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));
float2 speed = _Time.y * float2(_WaveXSpeed,_WaveYSpeed);
```

 偏移坐标对**噪声纹理**（即法线纹理）采样

_Distortion 和 _RefractionTex_TexelSize都是开放的参数，影响波动幅度和范围

采样两次叠加是为了模拟两层交叉水面的效果

```
fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;
fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;
fixed3 bump = normalize(bump1 + bump2);
float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;
```

bump（采样结果）切换到世界空间

```
bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));
```

这里不是

```
i.scrPos.xy = offset+ i.scrPos.xy;
```

而是

```
i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;
```

是为了模拟深度越大波动越大的效果

对srcpos做透视除法，并对屏幕图像采样，得到折射颜色

```
fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;
```

计算反射方向，并对cubemap采样，得到反射颜色

```
fixed3 reflDir = reflect(-viewDir, bump);
fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;
```

菲涅尔系数得到最终效果

```
fixed fresnel = pow(1 - saturate(dot(viewDir, bump)), 4);
				fixed3 finalColor = reflCol * fresnel + refrCol * (1 - fresnel);
				return fixed4(finalColor, 1);
```

### 15.3全局雾效+噪声

代码大部分照抄13.3

这是原代码，求系数和开放的系数相乘得到雾效颜色

```
float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); 
fogDensity = saturate(fogDensity * _FogDensity);
```

新代码加入噪声处理

```
float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);
float noise = (tex2D(_NoiseTex, i.uv + speed).r - 0.5) * _NoiseAmount;
```

对应地噪声参与了雾效生成，说白了就是雾效深度乘一个[0,1]的系数

```
fogDensity = saturate(fogDensity * _FogDensity * (1 + noise));
```

